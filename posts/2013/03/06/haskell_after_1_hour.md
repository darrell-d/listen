MAR 06 2013
#HASKELL AFTER 1 HOUR

I've written software imperatively for almost a decade now. In fact I was barely aware that there were other ways to write it until I was introduced to [Scheme](http://en.wikipedia.org/wiki/Scheme_(programming_language)) in my junior year of college, I even wrote an interpreter for it.

Scheme was certainly an oddity to me when I was first introduced to it. With most imperative languages I could look up a few syntax idioms and be on my way to writing basic scripts. With Scheme it felt like I had to learn to program all over again. It made me feel dense as everything I did I had to do slowly before I thought it was right, and then I had to wade through what seemed like a never ending stream of error messages at compile time.

But I powered through it, participated in class, got my assignments done, passed the tests, wrote an interpreter and moved on. At the end of it all I thought I would say goodbye to functional programming forever.

Fast forward 3 years and here I am learning Haskell. I have no reason or explanation for what made me pick it up other than a mixture of curiosity and boredom on a slow afternoon. Someone had linked to [Learn You A Haskell for Great Good](http://learnyouahaskell.com/) and I decided to take another look at functional programming. After an hour in what once felt slow, awkward and painful now made me feel empowered.

So far I'm about 3 Chapters into the book but here is what I've found so far: Haskell makes thinking of problems easier. Let's take a look at a [FizzBuzz](http://en.wikipedia.org/wiki/Fizz_buzz) solution and a few slight variants in Haskell that I decided to code up after an hour of reading to gauge my understanding:

<blockquote class = 'code'>
fizzBuzz y  =
	[
		if x `mod` 15 ==0 then
		"FizzBuzz"
		else if x `mod ` 5 ==0 then
		"Buzz" else if x `mod` 3 == 0 then
		"Fizz" else show x
			| x<-[1..y]
	]
</blockquote>
This will generate a fizzbuzz solution for **y** numbers when called:

    *Main> fizzBuzz 15
    ["1","2","Fizz","4","Buzz","Fizz","7","8","Fizz","Buzz","11","Fizz","13","14","FizzBuzz"]

On the first line I declare my function **fizzBuzz** and pass it my parameter **y**. The body of the function exists between the square braces.

Before we move on let's talk about [Comprehension Sets](http://en.wikipedia.org/wiki/Set-builder_notation).

Here is a Comprehension Set:

<img src='http://i.imgur.com/1b1nmkr.png'>

Don't panic. It's just a little math.

What it says is that we want a list of values **S** which will be generated by the output function __2*x__.

**x**, our variable, must be part of our input set (**N**) and our predicate says **x^2** must be greater than 3.

<img src = 'http://i.imgur.com/bfy9ujj.png'>

Comprehension sets are a very concise way of representing data and Haskell utilizes this.

The **if else if else** block is our function part of the Comprehension set. The **x<-[1..y]** serves as our input and for this example we don't have a predicate. The input bears a little more explanation.

**[1..y]** gives us a list of numbers from 1 to **y**.

**x<-** will take each value from the list in turn. This is a built in feature of Haskell.

If we did want a predicate,we would just add it in after the input. For example if we only wanted even numbers
<blockquote class = 'code'>
fizzBuzz y  =
	[
		if x `mod` 15 ==0 then
		"FizzBuzz"
		else if x `mod ` 5 ==0 then
		"Buzz" else if x `mod` 3 == 0 then
		"Fizz" else show x
			| x<-[1..y], even x
	]
</blockquote>
Result:

    *Main> fizzBuzz 15
    ["2","4","Fizz","8","Buzz","Fizz","14"]

We can have as many predicates as we would like. Let's say we wanted only numbers which were greater than 42:

<blockquote class = 'code'>
fizzBuzz y  =
	[
		if x `mod` 15 ==0 then
		"FizzBuzz"
		else if x `mod ` 5 ==0 then
		"Buzz" else if x `mod` 3 == 0 then
		"Fizz" else show x
			| x<-[1..y], even x, x > 42
	]
</blockquote>

Results:
    *Main> fizzBuzz 75
    ["44","46","Fizz","Buzz","52","Fizz","56","58","FizzBuzz","62","64","Fizz","68","Buzz","Fizz","74"]

What if we wanted to control our input range to only check for multiples of 10? Haskell has a few built in functions to make this easy with lists. Haskell can check for patterns when we're making a list if we seed the first few values:
<blockquote class = 'code'>
fizzBuzz y  =
	[
		if x `mod` 15 ==0 then
		"FizzBuzz"
		else if x `mod ` 5 ==0 then
		"Buzz" else if x `mod` 3 == 0 then
		"Fizz" else show x
			| x<-[10,20..y]
	]
</blockquote>
Results:

    *Main> fizzBuzz 100
    ["Buzz","Buzz","FizzBuzz","Buzz","Buzz","FizzBuzz","Buzz","Buzz","FizzBuzz","Buzz"]


These are just a few of the things that I've found very neat in Haskell from 1 hour of playing with it. Coding these solutions would have been close to trivial in C or Java, but Haskell makes for very concise code in a few lines.

The [benefits of functoinal programming](http://stackoverflow.com/a/128128/410802) are [plentiful I'm told](http://c2.com/cgi/wiki?AdvantagesOfFunctionalProgramming). The issue of correctness especially interests me for web development as it could possibly lead to inherent security benefits and fewer headaches.
